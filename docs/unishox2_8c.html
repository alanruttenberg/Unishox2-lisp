<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Unishox: unishox2.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="siara_cc_3d.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Unishox
   </div>
   <div id="projectbrief">A hybrid encoder for Short Unicode Strings</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('unishox2_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">unishox2.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Main code of Unishox2 Compression and Decompression library.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;ctype.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;limits.h&gt;</code><br />
<code>#include &quot;<a class="el" href="unishox2_8h.html">unishox2.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a724f98cac06320eed87c51708809f096"><td class="memItemLeft" align="right" valign="top"><a id="a724f98cac06320eed87c51708809f096" name="a724f98cac06320eed87c51708809f096"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NICE_LEN</b>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:a724f98cac06320eed87c51708809f096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum length to consider as repeating sequence. <br /></td></tr>
<tr class="separator:a724f98cac06320eed87c51708809f096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d61d4507bece9381322cf5416b739b"><td class="memItemLeft" align="right" valign="top"><a id="ae9d61d4507bece9381322cf5416b739b" name="ae9d61d4507bece9381322cf5416b739b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RPT_CODE</b>&#160;&#160;&#160;((2 &lt;&lt; 5) + 26)</td></tr>
<tr class="memdesc:ae9d61d4507bece9381322cf5416b739b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set (USX_NUM - 2) and vertical code (26) for encoding repeating letters. <br /></td></tr>
<tr class="separator:ae9d61d4507bece9381322cf5416b739b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd3457e6a65dfddab1b1c38fdbdacfa"><td class="memItemLeft" align="right" valign="top"><a id="a2fd3457e6a65dfddab1b1c38fdbdacfa" name="a2fd3457e6a65dfddab1b1c38fdbdacfa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TERM_CODE</b>&#160;&#160;&#160;((2 &lt;&lt; 5) + 27)</td></tr>
<tr class="memdesc:a2fd3457e6a65dfddab1b1c38fdbdacfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set (USX_NUM - 2) and vertical code (27) for encoding terminator. <br /></td></tr>
<tr class="separator:a2fd3457e6a65dfddab1b1c38fdbdacfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e1d61fec795d483196b5fff5205222"><td class="memItemLeft" align="right" valign="top"><a id="a83e1d61fec795d483196b5fff5205222" name="a83e1d61fec795d483196b5fff5205222"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LF_CODE</b>&#160;&#160;&#160;((1 &lt;&lt; 5) + 7)</td></tr>
<tr class="memdesc:a83e1d61fec795d483196b5fff5205222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set (USX_SYM - 1) and vertical code (7) for encoding Line feed \n. <br /></td></tr>
<tr class="separator:a83e1d61fec795d483196b5fff5205222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b3964720466e03683b214b17ae93c0e"><td class="memItemLeft" align="right" valign="top"><a id="a3b3964720466e03683b214b17ae93c0e" name="a3b3964720466e03683b214b17ae93c0e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CRLF_CODE</b>&#160;&#160;&#160;((1 &lt;&lt; 5) + 8)</td></tr>
<tr class="memdesc:a3b3964720466e03683b214b17ae93c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set (USX_NUM - 1) and vertical code (8) for encoding \r\n. <br /></td></tr>
<tr class="separator:a3b3964720466e03683b214b17ae93c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde80601b4d230c6e54cbd36906fdb2b"><td class="memItemLeft" align="right" valign="top"><a id="adde80601b4d230c6e54cbd36906fdb2b" name="adde80601b4d230c6e54cbd36906fdb2b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR_CODE</b>&#160;&#160;&#160;((1 &lt;&lt; 5) + 22)</td></tr>
<tr class="memdesc:adde80601b4d230c6e54cbd36906fdb2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set (USX_NUM - 1) and vertical code (22) for encoding \r. <br /></td></tr>
<tr class="separator:adde80601b4d230c6e54cbd36906fdb2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29f0ab13eb3b9bb68eaa6426e345ad7"><td class="memItemLeft" align="right" valign="top"><a id="ae29f0ab13eb3b9bb68eaa6426e345ad7" name="ae29f0ab13eb3b9bb68eaa6426e345ad7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TAB_CODE</b>&#160;&#160;&#160;((1 &lt;&lt; 5) + 14)</td></tr>
<tr class="memdesc:ae29f0ab13eb3b9bb68eaa6426e345ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set (USX_NUM - 1) and vertical code (14) for encoding \t. <br /></td></tr>
<tr class="separator:ae29f0ab13eb3b9bb68eaa6426e345ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7eb675f693cc8e915311a4d3bd9c68"><td class="memItemLeft" align="right" valign="top"><a id="a9d7eb675f693cc8e915311a4d3bd9c68" name="a9d7eb675f693cc8e915311a4d3bd9c68"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NUM_SPC_CODE</b>&#160;&#160;&#160;((2 &lt;&lt; 5) + 17)</td></tr>
<tr class="memdesc:a9d7eb675f693cc8e915311a4d3bd9c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set (USX_NUM - 2) and vertical code (17) for space character when it appears in USX_NUM state \r. <br /></td></tr>
<tr class="separator:a9d7eb675f693cc8e915311a4d3bd9c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612daee6e8b8c17d0b14fe22acd01cac"><td class="memItemLeft" align="right" valign="top"><a id="a612daee6e8b8c17d0b14fe22acd01cac" name="a612daee6e8b8c17d0b14fe22acd01cac"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UNI_STATE_SPL_CODE</b>&#160;&#160;&#160;0xF8</td></tr>
<tr class="memdesc:a612daee6e8b8c17d0b14fe22acd01cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Code for special code (11111) when state=USX_DELTA. <br /></td></tr>
<tr class="separator:a612daee6e8b8c17d0b14fe22acd01cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3fdd838200ef3bbf75d222b3452a8f"><td class="memItemLeft" align="right" valign="top"><a id="aaa3fdd838200ef3bbf75d222b3452a8f" name="aaa3fdd838200ef3bbf75d222b3452a8f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UNI_STATE_SPL_CODE_LEN</b>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:aaa3fdd838200ef3bbf75d222b3452a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of Code for special code when state=USX_DELTA. <br /></td></tr>
<tr class="separator:aaa3fdd838200ef3bbf75d222b3452a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af932b0f89dd13d9330e9932cb66b4483"><td class="memItemLeft" align="right" valign="top"><a id="af932b0f89dd13d9330e9932cb66b4483" name="af932b0f89dd13d9330e9932cb66b4483"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UNI_STATE_SW_CODE</b>&#160;&#160;&#160;0x80</td></tr>
<tr class="memdesc:af932b0f89dd13d9330e9932cb66b4483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Code for switch code when state=USX_DELTA. <br /></td></tr>
<tr class="separator:af932b0f89dd13d9330e9932cb66b4483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61cbf22635f28d8b618a9885d44c0334"><td class="memItemLeft" align="right" valign="top"><a id="a61cbf22635f28d8b618a9885d44c0334" name="a61cbf22635f28d8b618a9885d44c0334"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>UNI_STATE_SW_CODE_LEN</b>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a61cbf22635f28d8b618a9885d44c0334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of Code for Switch code when state=USX_DELTA. <br /></td></tr>
<tr class="separator:a61cbf22635f28d8b618a9885d44c0334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a1e0205f4a531268e55ba62a31cbcb"><td class="memItemLeft" align="right" valign="top"><a id="a10a1e0205f4a531268e55ba62a31cbcb" name="a10a1e0205f4a531268e55ba62a31cbcb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SW_CODE</b>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a10a1e0205f4a531268e55ba62a31cbcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch code in USX_ALPHA and USX_NUM 00. <br /></td></tr>
<tr class="separator:a10a1e0205f4a531268e55ba62a31cbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329e03dd40aeb8515328fd2ac450ecfd"><td class="memItemLeft" align="right" valign="top"><a id="a329e03dd40aeb8515328fd2ac450ecfd" name="a329e03dd40aeb8515328fd2ac450ecfd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SW_CODE_LEN</b>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a329e03dd40aeb8515328fd2ac450ecfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of Switch code. <br /></td></tr>
<tr class="separator:a329e03dd40aeb8515328fd2ac450ecfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af484931bbdca4f06855aa5f8db7a79c6"><td class="memItemLeft" align="right" valign="top"><a id="af484931bbdca4f06855aa5f8db7a79c6" name="af484931bbdca4f06855aa5f8db7a79c6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TERM_BYTE_PRESET_1</b>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:af484931bbdca4f06855aa5f8db7a79c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminator bit sequence for Preset 1. Length varies depending on state as per following macros. <br /></td></tr>
<tr class="separator:af484931bbdca4f06855aa5f8db7a79c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6735ecd33df64b142f28b83060a79c18"><td class="memItemLeft" align="right" valign="top"><a id="a6735ecd33df64b142f28b83060a79c18" name="a6735ecd33df64b142f28b83060a79c18"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TERM_BYTE_PRESET_1_LEN_LOWER</b>&#160;&#160;&#160;6</td></tr>
<tr class="memdesc:a6735ecd33df64b142f28b83060a79c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of Terminator bit sequence when state is lower. <br /></td></tr>
<tr class="separator:a6735ecd33df64b142f28b83060a79c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69ecbd402690434fc0a8830bcd51abb"><td class="memItemLeft" align="right" valign="top"><a id="ac69ecbd402690434fc0a8830bcd51abb" name="ac69ecbd402690434fc0a8830bcd51abb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TERM_BYTE_PRESET_1_LEN_UPPER</b>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:ac69ecbd402690434fc0a8830bcd51abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of Terminator bit sequence when state is upper. <br /></td></tr>
<tr class="separator:ac69ecbd402690434fc0a8830bcd51abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4876ce3fa9843bfb42794c735566532"><td class="memItemLeft" align="right" valign="top"><a id="ac4876ce3fa9843bfb42794c735566532" name="ac4876ce3fa9843bfb42794c735566532"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>USX_OFFSET_94</b>&#160;&#160;&#160;33</td></tr>
<tr class="memdesc:ac4876ce3fa9843bfb42794c735566532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset at which usx_code_94 starts. <br /></td></tr>
<tr class="separator:ac4876ce3fa9843bfb42794c735566532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6bcd9167ab1795ed6e31c7e256998c6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unishox2_8c.html#af6bcd9167ab1795ed6e31c7e256998c6">SAFE_APPEND_BITS</a>(exp)</td></tr>
<tr class="memdesc:af6bcd9167ab1795ed6e31c7e256998c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a safe call to <a class="el" href="unishox2_8c.html#a9c6276d2099c1fbb7976c84dcd9f49ff">append_bits()</a> making sure it does not write past olen.  <a href="unishox2_8c.html#af6bcd9167ab1795ed6e31c7e256998c6">More...</a><br /></td></tr>
<tr class="separator:af6bcd9167ab1795ed6e31c7e256998c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94aa81691fb41bc4884ade65a608504"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unishox2_8c.html#ae94aa81691fb41bc4884ade65a608504">SAFE_APPEND_BITS2</a>(olen,  exp)</td></tr>
<tr class="memdesc:ae94aa81691fb41bc4884ade65a608504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro used in the main compress function so that if the output len exceeds given maximum length (olen) it can exit.  <a href="unishox2_8c.html#ae94aa81691fb41bc4884ade65a608504">More...</a><br /></td></tr>
<tr class="separator:ae94aa81691fb41bc4884ade65a608504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0caed02969c367ffb6a3565fbe025e5e"><td class="memItemLeft" align="right" valign="top"><a id="a0caed02969c367ffb6a3565fbe025e5e" name="a0caed02969c367ffb6a3565fbe025e5e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SECTION_COUNT</b>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:a0caed02969c367ffb6a3565fbe025e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of veritical codes is split into 5 sections. Used by <a class="el" href="unishox2_8c.html#a6f3fdfda25ad93c1409d47283dcddfe7">readVCodeIdx()</a> <br /></td></tr>
<tr class="separator:a0caed02969c367ffb6a3565fbe025e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca30499bb16efdc1649a466da290374"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unishox2_8c.html#a7ca30499bb16efdc1649a466da290374">DEC_OUTPUT_CHAR</a>(out,  olen,  ol,  c)</td></tr>
<tr class="memdesc:a7ca30499bb16efdc1649a466da290374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to ensure that the decoder does not append more than olen bytes to out.  <a href="unishox2_8c.html#a7ca30499bb16efdc1649a466da290374">More...</a><br /></td></tr>
<tr class="separator:a7ca30499bb16efdc1649a466da290374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ea8b280ac24eddc2710085a600141f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unishox2_8c.html#a52ea8b280ac24eddc2710085a600141f">DEC_OUTPUT_CHARS</a>(olen,  exp)</td></tr>
<tr class="memdesc:a52ea8b280ac24eddc2710085a600141f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to ensure that the decoder does not append more than olen bytes to out.  <a href="unishox2_8c.html#a52ea8b280ac24eddc2710085a600141f">More...</a><br /></td></tr>
<tr class="separator:a52ea8b280ac24eddc2710085a600141f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0c8186d9b9b7880309c27230bbb5e69d"><td class="memItemLeft" align="right" valign="top"><a id="a0c8186d9b9b7880309c27230bbb5e69d" name="a0c8186d9b9b7880309c27230bbb5e69d"></a>
typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>byte</b></td></tr>
<tr class="memdesc:a0c8186d9b9b7880309c27230bbb5e69d"><td class="mdescLeft">&#160;</td><td class="mdescRight">byte is unsigned char <br /></td></tr>
<tr class="separator:a0c8186d9b9b7880309c27230bbb5e69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a06fc87d81c62e9abb8790b6e5713c55b"><td class="memItemLeft" align="right" valign="top"><a id="a06fc87d81c62e9abb8790b6e5713c55b" name="a06fc87d81c62e9abb8790b6e5713c55b"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<b>USX_ALPHA</b> = 0
, <b>USX_SYM</b>
, <b>USX_NUM</b>
, <b>USX_DICT</b>
, <br />
&#160;&#160;<b>USX_DELTA</b>
, <b>USX_NUM_TEMP</b>
<br />
 }</td></tr>
<tr class="memdesc:a06fc87d81c62e9abb8790b6e5713c55b"><td class="mdescLeft">&#160;</td><td class="mdescRight">possible horizontal sets and states <br /></td></tr>
<tr class="separator:a06fc87d81c62e9abb8790b6e5713c55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf764cbdea00d65edcd07bb9953ad2b7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>USX_NIB_NUM</b> = 0
, <b>USX_NIB_HEX_LOWER</b>
, <b>USX_NIB_HEX_UPPER</b>
, <b>USX_NIB_NOT</b>
 }</td></tr>
<tr class="separator:adf764cbdea00d65edcd07bb9953ad2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af4cff050d88960562fac68ad6af9346b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unishox2_8c.html#af4cff050d88960562fac68ad6af9346b">init_coder</a> ()</td></tr>
<tr class="separator:af4cff050d88960562fac68ad6af9346b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6276d2099c1fbb7976c84dcd9f49ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unishox2_8c.html#a9c6276d2099c1fbb7976c84dcd9f49ff">append_bits</a> (char *out, int olen, int ol, <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> code, int clen)</td></tr>
<tr class="separator:a9c6276d2099c1fbb7976c84dcd9f49ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02be4653b872089ee521f68c776c6869"><td class="memItemLeft" align="right" valign="top"><a id="a02be4653b872089ee521f68c776c6869" name="a02be4653b872089ee521f68c776c6869"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>append_switch_code</b> (char *out, int olen, int ol, <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> state)</td></tr>
<tr class="memdesc:a02be4653b872089ee521f68c776c6869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends switch code to out depending on the state (USX_DELTA or other) <br /></td></tr>
<tr class="separator:a02be4653b872089ee521f68c776c6869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7559accfc98eb1ed736025477131ef5"><td class="memItemLeft" align="right" valign="top"><a id="aa7559accfc98eb1ed736025477131ef5" name="aa7559accfc98eb1ed736025477131ef5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>append_code</b> (char *out, int olen, int ol, <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> code, <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *state, const <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> usx_hcodes[], const <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> usx_hcode_lens[])</td></tr>
<tr class="memdesc:aa7559accfc98eb1ed736025477131ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends given horizontal and veritical code bits to out. <br /></td></tr>
<tr class="separator:aa7559accfc98eb1ed736025477131ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4164d5eb180fa1f1c077f0a15df34d76"><td class="memItemLeft" align="right" valign="top"><a id="a4164d5eb180fa1f1c077f0a15df34d76" name="a4164d5eb180fa1f1c077f0a15df34d76"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>encodeCount</b> (char *out, int olen, int ol, int count)</td></tr>
<tr class="memdesc:a4164d5eb180fa1f1c077f0a15df34d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes given count to out. <br /></td></tr>
<tr class="separator:a4164d5eb180fa1f1c077f0a15df34d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ccf71a5aa0928165248ac639e84624f"><td class="memItemLeft" align="right" valign="top"><a id="a5ccf71a5aa0928165248ac639e84624f" name="a5ccf71a5aa0928165248ac639e84624f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>encodeUnicode</b> (char *out, int olen, int ol, int32_t code, int32_t prev_code)</td></tr>
<tr class="memdesc:a5ccf71a5aa0928165248ac639e84624f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the unicode code point given by code to out. prev_code is used to calculate the delta. <br /></td></tr>
<tr class="separator:a5ccf71a5aa0928165248ac639e84624f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c61649fdd860cc9f93a00c62213470"><td class="memItemLeft" align="right" valign="top"><a id="a40c61649fdd860cc9f93a00c62213470" name="a40c61649fdd860cc9f93a00c62213470"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><b>readUTF8</b> (const char *in, int len, int l, int *utf8len)</td></tr>
<tr class="memdesc:a40c61649fdd860cc9f93a00c62213470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads UTF-8 character from in. Also returns the number of bytes occupied by the UTF-8 character in utf8len. <br /></td></tr>
<tr class="separator:a40c61649fdd860cc9f93a00c62213470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8121bc004ecb3ca6e0fbd471fc1b88b6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unishox2_8c.html#a8121bc004ecb3ca6e0fbd471fc1b88b6">matchOccurance</a> (const char *in, int len, int l, char *out, int olen, int *ol, <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *state, const <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> usx_hcodes[], const <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> usx_hcode_lens[])</td></tr>
<tr class="separator:a8121bc004ecb3ca6e0fbd471fc1b88b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b41b73b51576ce9c9c9cf0d1604581e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unishox2_8c.html#a0b41b73b51576ce9c9c9cf0d1604581e">matchLine</a> (const char *in, int len, int l, char *out, int olen, int *ol, struct <a class="el" href="structus__lnk__lst.html">us_lnk_lst</a> *prev_lines, <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *state, const <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> usx_hcodes[], const <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> usx_hcode_lens[])</td></tr>
<tr class="separator:a0b41b73b51576ce9c9c9cf0d1604581e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e34ccbcf8ecffec2f0597484ed2587"><td class="memItemLeft" align="right" valign="top"><a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unishox2_8c.html#a75e34ccbcf8ecffec2f0597484ed2587">getBaseCode</a> (char ch)</td></tr>
<tr class="separator:a75e34ccbcf8ecffec2f0597484ed2587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7770cce3b7324d1f1622ce934a9b3d"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unishox2_8c.html#aaf7770cce3b7324d1f1622ce934a9b3d">getNibbleType</a> (char ch)</td></tr>
<tr class="separator:aaf7770cce3b7324d1f1622ce934a9b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f024df742b0a0ebd9f20c298cde80f"><td class="memItemLeft" align="right" valign="top"><a id="ac3f024df742b0a0ebd9f20c298cde80f" name="ac3f024df742b0a0ebd9f20c298cde80f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>append_nibble_escape</b> (char *out, int olen, int ol, <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> state, const <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> usx_hcodes[], const <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> usx_hcode_lens[])</td></tr>
<tr class="memdesc:ac3f024df742b0a0ebd9f20c298cde80f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts coding of nibble sets. <br /></td></tr>
<tr class="separator:ac3f024df742b0a0ebd9f20c298cde80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c70e9f9627682f92030c65708f54198"><td class="memItemLeft" align="right" valign="top"><a id="a5c70e9f9627682f92030c65708f54198" name="a5c70e9f9627682f92030c65708f54198"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>min_of</b> (long c, long i)</td></tr>
<tr class="memdesc:a5c70e9f9627682f92030c65708f54198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns minimum value of two longs. <br /></td></tr>
<tr class="separator:a5c70e9f9627682f92030c65708f54198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420cad7fb6a3076ae16f8f98cc7e8c26"><td class="memItemLeft" align="right" valign="top"><a id="a420cad7fb6a3076ae16f8f98cc7e8c26" name="a420cad7fb6a3076ae16f8f98cc7e8c26"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>append_final_bits</b> (char *const out, const int olen, int ol, const <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> state, const <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> is_all_upper, const <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> usx_hcodes[], const <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> usx_hcode_lens[])</td></tr>
<tr class="memdesc:a420cad7fb6a3076ae16f8f98cc7e8c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the terminator code depending on the state, preset and whether full terminator needs to be encoded to out or not <br  />
. <br /></td></tr>
<tr class="separator:a420cad7fb6a3076ae16f8f98cc7e8c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759f6131a89c84a206b7ce9d8bc73a78"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unishox2_8c.html#a759f6131a89c84a206b7ce9d8bc73a78">unishox2_compress_lines</a> (const char *in, int len, <a class="el" href="unishox2_8h.html#a147b75fc8de9ab4176b7cfb3d341f361">UNISHOX_API_OUT_AND_LEN</a>(char *out, int olen), const <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> usx_hcodes[], const <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> usx_hcode_lens[], const char *usx_freq_seq[], const char *usx_templates[], struct <a class="el" href="structus__lnk__lst.html">us_lnk_lst</a> *prev_lines)</td></tr>
<tr class="separator:a759f6131a89c84a206b7ce9d8bc73a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f58e19f06f8e7d0d1bb4b750f1f7c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unishox2_8c.html#af7f58e19f06f8e7d0d1bb4b750f1f7c4">unishox2_compress</a> (const char *in, int len, <a class="el" href="unishox2_8h.html#a147b75fc8de9ab4176b7cfb3d341f361">UNISHOX_API_OUT_AND_LEN</a>(char *out, int olen), const <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> usx_hcodes[], const <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> usx_hcode_lens[], const char *usx_freq_seq[], const char *usx_templates[])</td></tr>
<tr class="separator:af7f58e19f06f8e7d0d1bb4b750f1f7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37df146e9ddd9ff1b07c7c160683d96c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unishox2_8c.html#a37df146e9ddd9ff1b07c7c160683d96c">unishox2_compress_simple</a> (const char *in, int len, char *out)</td></tr>
<tr class="separator:a37df146e9ddd9ff1b07c7c160683d96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7beb403f827431311c87c9b91fa12f5"><td class="memItemLeft" align="right" valign="top"><a id="af7beb403f827431311c87c9b91fa12f5" name="af7beb403f827431311c87c9b91fa12f5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>readBit</b> (const char *in, int bit_no)</td></tr>
<tr class="separator:af7beb403f827431311c87c9b91fa12f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7b6640fad65d18e9f66cb71094726f"><td class="memItemLeft" align="right" valign="top"><a id="aba7b6640fad65d18e9f66cb71094726f" name="aba7b6640fad65d18e9f66cb71094726f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>read8bitCode</b> (const char *in, int len, int bit_no)</td></tr>
<tr class="separator:aba7b6640fad65d18e9f66cb71094726f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3fdfda25ad93c1409d47283dcddfe7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unishox2_8c.html#a6f3fdfda25ad93c1409d47283dcddfe7">readVCodeIdx</a> (const char *in, int len, int *bit_no_p)</td></tr>
<tr class="separator:a6f3fdfda25ad93c1409d47283dcddfe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997e044cfcdec668607bd203607b2c77"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unishox2_8c.html#a997e044cfcdec668607bd203607b2c77">readHCodeIdx</a> (const char *in, int len, int *bit_no_p, const <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> usx_hcodes[], const <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> usx_hcode_lens[])</td></tr>
<tr class="separator:a997e044cfcdec668607bd203607b2c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6dd94aa6b1641044305bac4d3a5b261"><td class="memItemLeft" align="right" valign="top"><a id="af6dd94aa6b1641044305bac4d3a5b261" name="af6dd94aa6b1641044305bac4d3a5b261"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getStepCodeIdx</b> (const char *in, int len, int *bit_no_p, int limit)</td></tr>
<tr class="memdesc:af6dd94aa6b1641044305bac4d3a5b261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of step code (0, 10, 110, etc.) encountered in the stream. <br /></td></tr>
<tr class="separator:af6dd94aa6b1641044305bac4d3a5b261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b917b750c7765551970478c66442af6"><td class="memItemLeft" align="right" valign="top"><a id="a7b917b750c7765551970478c66442af6" name="a7b917b750c7765551970478c66442af6"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><b>getNumFromBits</b> (const char *in, int len, int bit_no, int count)</td></tr>
<tr class="memdesc:a7b917b750c7765551970478c66442af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads specified number of bits and builds the corresponding integer. <br /></td></tr>
<tr class="separator:a7b917b750c7765551970478c66442af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614d1b07fece14ccbe5375cffa1edd12"><td class="memItemLeft" align="right" valign="top"><a id="a614d1b07fece14ccbe5375cffa1edd12" name="a614d1b07fece14ccbe5375cffa1edd12"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><b>readCount</b> (const char *in, int *bit_no_p, int len)</td></tr>
<tr class="memdesc:a614d1b07fece14ccbe5375cffa1edd12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the count from the given bit stream at in. Also updates bit_no_p. <br /></td></tr>
<tr class="separator:a614d1b07fece14ccbe5375cffa1edd12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d5cbe46a0752c2321b1dd40d80309d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unishox2_8c.html#a15d5cbe46a0752c2321b1dd40d80309d">readUnicode</a> (const char *in, int *bit_no_p, int len)</td></tr>
<tr class="separator:a15d5cbe46a0752c2321b1dd40d80309d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559a926b123cad02f7af04c2d4f8a8d2"><td class="memItemLeft" align="right" valign="top"><a id="a559a926b123cad02f7af04c2d4f8a8d2" name="a559a926b123cad02f7af04c2d4f8a8d2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>writeUTF8</b> (char *out, int olen, int ol, int uni)</td></tr>
<tr class="memdesc:a559a926b123cad02f7af04c2d4f8a8d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write given unicode code point to out as a UTF-8 sequence. <br /></td></tr>
<tr class="separator:a559a926b123cad02f7af04c2d4f8a8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67aee5a37adae65a8560d0ab1aab46a"><td class="memItemLeft" align="right" valign="top"><a id="ab67aee5a37adae65a8560d0ab1aab46a" name="ab67aee5a37adae65a8560d0ab1aab46a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>decodeRepeat</b> (const char *in, int len, char *out, int olen, int ol, int *bit_no, struct <a class="el" href="structus__lnk__lst.html">us_lnk_lst</a> *prev_lines)</td></tr>
<tr class="memdesc:ab67aee5a37adae65a8560d0ab1aab46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode repeating sequence and appends to out. <br /></td></tr>
<tr class="separator:ab67aee5a37adae65a8560d0ab1aab46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ac8ed467720baa525e93e24700e448"><td class="memItemLeft" align="right" valign="top"><a id="a03ac8ed467720baa525e93e24700e448" name="a03ac8ed467720baa525e93e24700e448"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><b>getHexChar</b> (int32_t nibble, int hex_type)</td></tr>
<tr class="memdesc:a03ac8ed467720baa525e93e24700e448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns hex character corresponding to the 4 bit nibble. <br /></td></tr>
<tr class="separator:a03ac8ed467720baa525e93e24700e448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec21ab3385bd5920e2ce6c63d1ebf418"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unishox2_8c.html#aec21ab3385bd5920e2ce6c63d1ebf418">unishox2_decompress_lines</a> (const char *in, int len, <a class="el" href="unishox2_8h.html#a147b75fc8de9ab4176b7cfb3d341f361">UNISHOX_API_OUT_AND_LEN</a>(char *out, int olen), const <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> usx_hcodes[], const <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> usx_hcode_lens[], const char *usx_freq_seq[], const char *usx_templates[], struct <a class="el" href="structus__lnk__lst.html">us_lnk_lst</a> *prev_lines)</td></tr>
<tr class="separator:aec21ab3385bd5920e2ce6c63d1ebf418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7c35fe5cf2bfab017580f19a1a2d01"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unishox2_8c.html#a6e7c35fe5cf2bfab017580f19a1a2d01">unishox2_decompress</a> (const char *in, int len, <a class="el" href="unishox2_8h.html#a147b75fc8de9ab4176b7cfb3d341f361">UNISHOX_API_OUT_AND_LEN</a>(char *out, int olen), const <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> usx_hcodes[], const <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> usx_hcode_lens[], const char *usx_freq_seq[], const char *usx_templates[])</td></tr>
<tr class="separator:a6e7c35fe5cf2bfab017580f19a1a2d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5c00a0c5db7979d94b0b294908a04e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unishox2_8c.html#a3e5c00a0c5db7979d94b0b294908a04e">unishox2_decompress_simple</a> (const char *in, int len, char *out)</td></tr>
<tr class="separator:a3e5c00a0c5db7979d94b0b294908a04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a26a0225aca0ec7d93e62587226d752f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unishox2_8c.html#a26a0225aca0ec7d93e62587226d752f3">usx_sets</a> [][28]</td></tr>
<tr class="memdesc:a26a0225aca0ec7d93e62587226d752f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This 2D array has the characters for the sets USX_ALPHA, USX_SYM and USX_NUM. Where a character cannot fit into a byte, 0 is used and handled in code.  <a href="unishox2_8c.html#a26a0225aca0ec7d93e62587226d752f3">More...</a><br /></td></tr>
<tr class="separator:a26a0225aca0ec7d93e62587226d752f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e8ea73201a929db219744e046a7012"><td class="memItemLeft" align="right" valign="top"><a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unishox2_8c.html#ad8e8ea73201a929db219744e046a7012">usx_code_94</a> [94]</td></tr>
<tr class="separator:ad8e8ea73201a929db219744e046a7012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc351d1b7a92d0654c3035dfe548a1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unishox2_8c.html#a7bc351d1b7a92d0654c3035dfe548a1d">usx_vcodes</a> []</td></tr>
<tr class="memdesc:a7bc351d1b7a92d0654c3035dfe548a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertical codes starting from the MSB.  <a href="unishox2_8c.html#a7bc351d1b7a92d0654c3035dfe548a1d">More...</a><br /></td></tr>
<tr class="separator:a7bc351d1b7a92d0654c3035dfe548a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b3914e2fcfcedd6fe942f752ded63f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unishox2_8c.html#a3b3914e2fcfcedd6fe942f752ded63f6">usx_vcode_lens</a> []</td></tr>
<tr class="memdesc:a3b3914e2fcfcedd6fe942f752ded63f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of each veritical code.  <a href="unishox2_8c.html#a3b3914e2fcfcedd6fe942f752ded63f6">More...</a><br /></td></tr>
<tr class="separator:a3b3914e2fcfcedd6fe942f752ded63f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9df0838af5c0cd50792445d70977835"><td class="memItemLeft" align="right" valign="top"><a id="aa9df0838af5c0cd50792445d70977835" name="aa9df0838af5c0cd50792445d70977835"></a>
<a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><b>usx_freq_codes</b> [] = {(1 &lt;&lt; 5) + 25, (1 &lt;&lt; 5) + 26, (1 &lt;&lt; 5) + 27, (2 &lt;&lt; 5) + 23, (2 &lt;&lt; 5) + 24, (2 &lt;&lt; 5) + 25}</td></tr>
<tr class="memdesc:aa9df0838af5c0cd50792445d70977835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertical Codes and Set number for frequent sequences in sets USX_SYM and USX_NUM. First 3 bits indicate set (USX_SYM/USX_NUM) and rest are vcode positions. <br /></td></tr>
<tr class="separator:aa9df0838af5c0cd50792445d70977835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a002e865b368b3f44c3c5c381fe186"><td class="memItemLeft" align="right" valign="top"><a id="a88a002e865b368b3f44c3c5c381fe186" name="a88a002e865b368b3f44c3c5c381fe186"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>UTF8_MASK</b> [] = {0xE0, 0xF0, 0xF8}</td></tr>
<tr class="memdesc:a88a002e865b368b3f44c3c5c381fe186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not used. <br /></td></tr>
<tr class="separator:a88a002e865b368b3f44c3c5c381fe186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddfdf39731e05a09b8c202dd1f46fc5"><td class="memItemLeft" align="right" valign="top"><a id="a9ddfdf39731e05a09b8c202dd1f46fc5" name="a9ddfdf39731e05a09b8c202dd1f46fc5"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>UTF8_PREFIX</b> [] = {0xC0, 0xE0, 0xF0}</td></tr>
<tr class="memdesc:a9ddfdf39731e05a09b8c202dd1f46fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not used. <br /></td></tr>
<tr class="separator:a9ddfdf39731e05a09b8c202dd1f46fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9564a66a4ec8428ad6e701194a78fe"><td class="memItemLeft" align="right" valign="top"><a id="a0a9564a66a4ec8428ad6e701194a78fe" name="a0a9564a66a4ec8428ad6e701194a78fe"></a>
<a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_inited</b> = 0</td></tr>
<tr class="memdesc:a0a9564a66a4ec8428ad6e701194a78fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">global to indicate whether initialization is complete or not <br /></td></tr>
<tr class="separator:a0a9564a66a4ec8428ad6e701194a78fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b9db0e1bbfc7fdeca37d28109b3ee6"><td class="memItemLeft" align="right" valign="top"><a id="ac9b9db0e1bbfc7fdeca37d28109b3ee6" name="ac9b9db0e1bbfc7fdeca37d28109b3ee6"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>usx_mask</b> [] = {0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE, 0xFF}</td></tr>
<tr class="memdesc:ac9b9db0e1bbfc7fdeca37d28109b3ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask for retrieving each code to be encoded according to its length. <br /></td></tr>
<tr class="separator:ac9b9db0e1bbfc7fdeca37d28109b3ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d0c196333d6a725df77e66e56ea4a6"><td class="memItemLeft" align="right" valign="top"><a id="aa3d0c196333d6a725df77e66e56ea4a6" name="aa3d0c196333d6a725df77e66e56ea4a6"></a>
const <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><b>count_bit_lens</b> [5] = {2, 4, 7, 11, 16}</td></tr>
<tr class="memdesc:aa3d0c196333d6a725df77e66e56ea4a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of bits used to represent count for each level. <br /></td></tr>
<tr class="separator:aa3d0c196333d6a725df77e66e56ea4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd21b78af275da0dabe45def1683722a"><td class="memItemLeft" align="right" valign="top"><a id="afd21b78af275da0dabe45def1683722a" name="afd21b78af275da0dabe45def1683722a"></a>
const int32_t&#160;</td><td class="memItemRight" valign="bottom"><b>count_adder</b> [5] = {4, 20, 148, 2196, 67732}</td></tr>
<tr class="memdesc:afd21b78af275da0dabe45def1683722a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cumulative counts represented at each level. <br /></td></tr>
<tr class="separator:afd21b78af275da0dabe45def1683722a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe83a714fda1fa30ba0f4e670e117c1"><td class="memItemLeft" align="right" valign="top"><a id="acfe83a714fda1fa30ba0f4e670e117c1" name="acfe83a714fda1fa30ba0f4e670e117c1"></a>
const <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><b>count_codes</b> [] = {0x01, 0x82, 0xC3, 0xE4, 0xF4}</td></tr>
<tr class="memdesc:acfe83a714fda1fa30ba0f4e670e117c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Codes used to specify the level that the count belongs to. <br /></td></tr>
<tr class="separator:acfe83a714fda1fa30ba0f4e670e117c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ec6eda9841aa469d659b5f33bf2a33"><td class="memItemLeft" align="right" valign="top"><a id="a78ec6eda9841aa469d659b5f33bf2a33" name="a78ec6eda9841aa469d659b5f33bf2a33"></a>
const <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><b>uni_bit_len</b> [5] = {6, 12, 14, 16, 21}</td></tr>
<tr class="memdesc:a78ec6eda9841aa469d659b5f33bf2a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of bits used to represent delta code for each level. <br /></td></tr>
<tr class="separator:a78ec6eda9841aa469d659b5f33bf2a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c7fee149d3af0ab41a8b2cc4db40d3"><td class="memItemLeft" align="right" valign="top"><a id="ae8c7fee149d3af0ab41a8b2cc4db40d3" name="ae8c7fee149d3af0ab41a8b2cc4db40d3"></a>
const int32_t&#160;</td><td class="memItemRight" valign="bottom"><b>uni_adder</b> [5] = {0, 64, 4160, 20544, 86080}</td></tr>
<tr class="memdesc:ae8c7fee149d3af0ab41a8b2cc4db40d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cumulative delta codes represented at each level. <br /></td></tr>
<tr class="separator:ae8c7fee149d3af0ab41a8b2cc4db40d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bda14d778dc04b63f2bc89f37967804"><td class="memItemLeft" align="right" valign="top"><a id="a4bda14d778dc04b63f2bc89f37967804" name="a4bda14d778dc04b63f2bc89f37967804"></a>
<a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><b>usx_vsections</b> [] = {0x7F, 0xBF, 0xDF, 0xEF, 0xFF}</td></tr>
<tr class="memdesc:a4bda14d778dc04b63f2bc89f37967804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by <a class="el" href="unishox2_8c.html#a6f3fdfda25ad93c1409d47283dcddfe7">readVCodeIdx()</a> for finding the section under which the code read using read8bitCode() falls. <br /></td></tr>
<tr class="separator:a4bda14d778dc04b63f2bc89f37967804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03da640cfc08d7a3f65da6a45fc28564"><td class="memItemLeft" align="right" valign="top"><a id="a03da640cfc08d7a3f65da6a45fc28564" name="a03da640cfc08d7a3f65da6a45fc28564"></a>
<a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><b>usx_vsection_pos</b> [] = {0, 4, 8, 12, 20}</td></tr>
<tr class="memdesc:a03da640cfc08d7a3f65da6a45fc28564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by <a class="el" href="unishox2_8c.html#a6f3fdfda25ad93c1409d47283dcddfe7">readVCodeIdx()</a> for finding the section vertical position offset. <br /></td></tr>
<tr class="separator:a03da640cfc08d7a3f65da6a45fc28564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ceda812e0d9c9c719f2944b3771e2e1"><td class="memItemLeft" align="right" valign="top"><a id="a7ceda812e0d9c9c719f2944b3771e2e1" name="a7ceda812e0d9c9c719f2944b3771e2e1"></a>
<a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><b>usx_vsection_mask</b> [] = {0x7F, 0x3F, 0x1F, 0x0F, 0x0F}</td></tr>
<tr class="memdesc:a7ceda812e0d9c9c719f2944b3771e2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by <a class="el" href="unishox2_8c.html#a6f3fdfda25ad93c1409d47283dcddfe7">readVCodeIdx()</a> for masking the code read by read8bitCode() <br /></td></tr>
<tr class="separator:a7ceda812e0d9c9c719f2944b3771e2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36b4ddaf12b3ae27e7668e741b29bab"><td class="memItemLeft" align="right" valign="top"><a id="af36b4ddaf12b3ae27e7668e741b29bab" name="af36b4ddaf12b3ae27e7668e741b29bab"></a>
<a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><b>usx_vsection_shift</b> [] = {5, 4, 3, 1, 0}</td></tr>
<tr class="memdesc:af36b4ddaf12b3ae27e7668e741b29bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by <a class="el" href="unishox2_8c.html#a6f3fdfda25ad93c1409d47283dcddfe7">readVCodeIdx()</a> for shifting the code read by read8bitCode() to obtain the vpos. <br /></td></tr>
<tr class="separator:af36b4ddaf12b3ae27e7668e741b29bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ab0186ce66a2b8227bf72b2a9499a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unishox2_8c.html#aa8ab0186ce66a2b8227bf72b2a9499a6">usx_vcode_lookup</a> [36]</td></tr>
<tr class="separator:aa8ab0186ce66a2b8227bf72b2a9499a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9dde3029bc4d65f66f0fd275e9e85ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unishox2_8c.html#ab9dde3029bc4d65f66f0fd275e9e85ac">len_masks</a> [] = {0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE, 0xFF}</td></tr>
<tr class="separator:ab9dde3029bc4d65f66f0fd275e9e85ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Main code of Unishox2 Compression and Decompression library. </p>
<dl class="section author"><dt>Author</dt><dd>Arundale Ramanathan, James Z. M. Gao</dd></dl>
<p>This file implements the code for the Unishox API function <br  />
defined in <a class="el" href="unishox2_8h.html" title="API for Unishox2 Compression and Decompression.">unishox2.h</a> </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a7ca30499bb16efdc1649a466da290374" name="a7ca30499bb16efdc1649a466da290374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca30499bb16efdc1649a466da290374">&#9670;&nbsp;</a></span>DEC_OUTPUT_CHAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEC_OUTPUT_CHAR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">out, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">olen, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ol, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> { \</div>
<div class="line">  char *<span class="keyword">const</span> obuf = (out); \</div>
<div class="line">  const <span class="keywordtype">int</span> oidx = (ol); \</div>
<div class="line">  const <span class="keywordtype">int</span> limit = (olen); \</div>
<div class="line">  if (limit &lt;= oidx) <span class="keywordflow">return</span> limit + 1; \</div>
<div class="line">  else <span class="keywordflow">if</span> (oidx &lt; 0) <span class="keywordflow">return</span> 0; \</div>
<div class="line">  else obuf[oidx] = (c); \</div>
<div class="line">} <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
<p>Macro to ensure that the decoder does not append more than olen bytes to out. </p>

</div>
</div>
<a id="a52ea8b280ac24eddc2710085a600141f" name="a52ea8b280ac24eddc2710085a600141f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ea8b280ac24eddc2710085a600141f">&#9670;&nbsp;</a></span>DEC_OUTPUT_CHARS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEC_OUTPUT_CHARS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">olen, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">exp&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> { \</div>
<div class="line">  const <span class="keywordtype">int</span> newidx = (exp); \</div>
<div class="line">  const <span class="keywordtype">int</span> limit = (olen); \</div>
<div class="line">  if (newidx &gt; limit) <span class="keywordflow">return</span> limit + 1; \</div>
<div class="line">} <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
<p>Macro to ensure that the decoder does not append more than olen bytes to out. </p>

</div>
</div>
<a id="af6bcd9167ab1795ed6e31c7e256998c6" name="af6bcd9167ab1795ed6e31c7e256998c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6bcd9167ab1795ed6e31c7e256998c6">&#9670;&nbsp;</a></span>SAFE_APPEND_BITS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SAFE_APPEND_BITS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">exp</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> { \</div>
<div class="line">  const <span class="keywordtype">int</span> newidx = (exp); \</div>
<div class="line">  if (newidx &lt; 0) return newidx; \</div>
<div class="line">} while (0)</div>
</div><!-- fragment -->
<p>This is a safe call to <a class="el" href="unishox2_8c.html#a9c6276d2099c1fbb7976c84dcd9f49ff">append_bits()</a> making sure it does not write past olen. </p>

</div>
</div>
<a id="ae94aa81691fb41bc4884ade65a608504" name="ae94aa81691fb41bc4884ade65a608504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94aa81691fb41bc4884ade65a608504">&#9670;&nbsp;</a></span>SAFE_APPEND_BITS2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SAFE_APPEND_BITS2</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">olen, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">exp&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> { \</div>
<div class="line">  const <span class="keywordtype">int</span> newidx = (exp); \</div>
<div class="line">  const <span class="keywordtype">int</span> __olen = (olen); \</div>
<div class="line">  if (newidx &lt; 0) return __olen &gt;= 0 ? __olen + 1 : (1 - __olen) * 4; \</div>
<div class="line">} while (0)</div>
</div><!-- fragment -->
<p>Macro used in the main compress function so that if the output len exceeds given maximum length (olen) it can exit. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="adf764cbdea00d65edcd07bb9953ad2b7" name="adf764cbdea00d65edcd07bb9953ad2b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf764cbdea00d65edcd07bb9953ad2b7">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Enum indicating nibble type - USX_NIB_NUM means ch is a number '0' to '9', <br  />
USX_NIB_HEX_LOWER means ch is between 'a' to 'f', <br  />
USX_NIB_HEX_UPPER means ch is between 'A' to 'F' </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9c6276d2099c1fbb7976c84dcd9f49ff" name="a9c6276d2099c1fbb7976c84dcd9f49ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c6276d2099c1fbb7976c84dcd9f49ff">&#9670;&nbsp;</a></span>append_bits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int append_bits </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>olen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>clen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Appends specified number of bits to the output (out) <br  />
If maximum limit (olen) is reached, -1 is returned <br  />
Otherwise clen bits in code are appended to out starting with MSB </p>

</div>
</div>
<a id="a75e34ccbcf8ecffec2f0597484ed2587" name="a75e34ccbcf8ecffec2f0597484ed2587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e34ccbcf8ecffec2f0597484ed2587">&#9670;&nbsp;</a></span>getBaseCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> getBaseCode </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns 4 bit code assuming ch falls between '0' to '9', <br  />
'A' to 'F' or 'a' to 'f' </p>

</div>
</div>
<a id="aaf7770cce3b7324d1f1622ce934a9b3d" name="aaf7770cce3b7324d1f1622ce934a9b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7770cce3b7324d1f1622ce934a9b3d">&#9670;&nbsp;</a></span>getNibbleType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char getNibbleType </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets 4 bit code assuming ch falls between '0' to '9', <br  />
'A' to 'F' or 'a' to 'f' </p>

</div>
</div>
<a id="af4cff050d88960562fac68ad6af9346b" name="af4cff050d88960562fac68ad6af9346b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4cff050d88960562fac68ad6af9346b">&#9670;&nbsp;</a></span>init_coder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_coder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Fills the usx_code_94 94 letter array based on sets of characters at usx_sets <br  />
For each element in usx_code_94, first 3 msb bits is set (USX_ALPHA / USX_SYM / USX_NUM) <br  />
and the rest 5 bits indicate the vertical position in the corresponding set </p>

</div>
</div>
<a id="a0b41b73b51576ce9c9c9cf0d1604581e" name="a0b41b73b51576ce9c9c9cf0d1604581e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b41b73b51576ce9c9c9cf0d1604581e">&#9670;&nbsp;</a></span>matchLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int matchLine </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>olen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structus__lnk__lst.html">us_lnk_lst</a> *&#160;</td>
          <td class="paramname"><em>prev_lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td>
          <td class="paramname"><em>usx_hcodes</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td>
          <td class="paramname"><em>usx_hcode_lens</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This is used only when encoding a string array Finds the longest matching sequence from the previous array element to the beginning of the string array. <br  />
If a match is found and it is longer than NICE_LEN, it is encoded as a repeating sequence to out <br  />
This is also used for Unicode strings <br  />
This is a crude implementation that is not optimized. Assuming only short strings <br  />
are encoded, this is not much of an issue. </p>

</div>
</div>
<a id="a8121bc004ecb3ca6e0fbd471fc1b88b6" name="a8121bc004ecb3ca6e0fbd471fc1b88b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8121bc004ecb3ca6e0fbd471fc1b88b6">&#9670;&nbsp;</a></span>matchOccurance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int matchOccurance </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>olen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td>
          <td class="paramname"><em>usx_hcodes</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td>
          <td class="paramname"><em>usx_hcode_lens</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Finds the longest matching sequence from the beginning of the string. <br  />
If a match is found and it is longer than NICE_LEN, it is encoded as a repeating sequence to out <br  />
This is also used for Unicode strings <br  />
This is a crude implementation that is not optimized. Assuming only short strings <br  />
are encoded, this is not much of an issue. </p>

</div>
</div>
<a id="a997e044cfcdec668607bd203607b2c77" name="a997e044cfcdec668607bd203607b2c77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a997e044cfcdec668607bd203607b2c77">&#9670;&nbsp;</a></span>readHCodeIdx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int readHCodeIdx </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>bit_no_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td>
          <td class="paramname"><em>usx_hcodes</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td>
          <td class="paramname"><em>usx_hcode_lens</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Decodes the horizontal code from the given bitstream at in <br  />
depending on the hcodes defined using usx_hcodes and usx_hcode_lens <br  />
Returns the horizontal code index or 99 if match could not be found. <br  />
Also updates bit_no_p with how many ever bits used by the horizontal code. </p>

</div>
</div>
<a id="a15d5cbe46a0752c2321b1dd40d80309d" name="a15d5cbe46a0752c2321b1dd40d80309d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d5cbe46a0752c2321b1dd40d80309d">&#9670;&nbsp;</a></span>readUnicode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t readUnicode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>bit_no_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Decodes the Unicode codepoint from the given bit stream at in. Also updates bit_no_p <br  />
When the step code is 5, reads the next step code to find out the special code. </p>

</div>
</div>
<a id="a6f3fdfda25ad93c1409d47283dcddfe7" name="a6f3fdfda25ad93c1409d47283dcddfe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f3fdfda25ad93c1409d47283dcddfe7">&#9670;&nbsp;</a></span>readVCodeIdx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int readVCodeIdx </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>bit_no_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Decodes the vertical code from the given bitstream at in <br  />
This is designed to use less memory using a 36 byte buffer <br  />
compared to using a 256 byte buffer to decode the next 8 bits read by read8bitCode() <br  />
by splitting the list of vertical codes. <br  />
Decoder is designed for using less memory, not speed. <br  />
Returns the veritical code index or 99 if match could not be found. <br  />
Also updates bit_no_p with how many ever bits used by the vertical code. </p>

</div>
</div>
<a id="af7f58e19f06f8e7d0d1bb4b750f1f7c4" name="af7f58e19f06f8e7d0d1bb4b750f1f7c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f58e19f06f8e7d0d1bb4b750f1f7c4">&#9670;&nbsp;</a></span>unishox2_compress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int unishox2_compress </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unishox2_8h.html#a147b75fc8de9ab4176b7cfb3d341f361">UNISHOX_API_OUT_AND_LEN</a>(char *out, int olen)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>usx_hcodes</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>usx_hcode_lens</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>usx_freq_seq</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>usx_templates</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Comprehensive API for compressing a string</p>
<p >Presets are available for the last four parameters so they can be passed as single parameter. <br  />
See USX_PSET_* macros. Example call: <br  />
 unishox2_compress(in, len, out, olen, USX_PSET_ALPHA_ONLY);</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>Input ASCII / UTF-8 string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length in bytes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>output buffer - should be large enough to hold compressed output </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">olen</td><td>length of 'out' buffer in bytes. Can be omitted if sufficient buffer is provided </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usx_hcodes</td><td>Horizontal codes (array of bytes). See macro section for samples. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usx_hcode_lens</td><td>Length of each element in usx_hcodes array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usx_freq_seq</td><td>Frequently occuring sequences. See USX_FREQ_SEQ_* macros for samples </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usx_templates</td><td>Templates of frequently occuring patterns. See USX_TEMPLATES macro. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a759f6131a89c84a206b7ce9d8bc73a78" name="a759f6131a89c84a206b7ce9d8bc73a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759f6131a89c84a206b7ce9d8bc73a78">&#9670;&nbsp;</a></span>unishox2_compress_lines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int unishox2_compress_lines </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unishox2_8h.html#a147b75fc8de9ab4176b7cfb3d341f361">UNISHOX_API_OUT_AND_LEN</a>(char *out, int olen)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>usx_hcodes</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>usx_hcode_lens</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>usx_freq_seq</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>usx_templates</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structus__lnk__lst.html">us_lnk_lst</a> *&#160;</td>
          <td class="paramname"><em>prev_lines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >More Comprehensive API for compressing array of strings</p>
<p >See <a class="el" href="unishox2_8h.html#a379f7637c1038582e5e3fcab27b4fae0">unishox2_compress()</a> function for parameter definitions. <br  />
This function takes an additional parameter, i.e. 'prev_lines' - the usx_lnk_lst structure <br  />
See -g parameter in test_unishox2.c to find out how this can be used. <br  />
This function is used when an array of strings need to be compressed <br  />
and stored in a compressed array of bytes for use as a constant in other programs <br  />
where each element of the array can be decompressed and used at runtime. </p>

</div>
</div>
<a id="a37df146e9ddd9ff1b07c7c160683d96c" name="a37df146e9ddd9ff1b07c7c160683d96c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37df146e9ddd9ff1b07c7c160683d96c">&#9670;&nbsp;</a></span>unishox2_compress_simple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int unishox2_compress_simple </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Simple API for compressing a string </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>Input ASCII / UTF-8 string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length in bytes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>output buffer - should be large enough to hold compressed output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e7c35fe5cf2bfab017580f19a1a2d01" name="a6e7c35fe5cf2bfab017580f19a1a2d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e7c35fe5cf2bfab017580f19a1a2d01">&#9670;&nbsp;</a></span>unishox2_decompress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int unishox2_decompress </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unishox2_8h.html#a147b75fc8de9ab4176b7cfb3d341f361">UNISHOX_API_OUT_AND_LEN</a>(char *out, int olen)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>usx_hcodes</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>usx_hcode_lens</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>usx_freq_seq</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>usx_templates</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Comprehensive API for de-compressing a string</p>
<p >Presets are available for the last four parameters so they can be passed as single parameter. <br  />
See USX_PSET_* macros. Example call: <br  />
 unishox2_decompress(in, len, out, olen, USX_PSET_ALPHA_ONLY);</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>Input compressed bytes (output of unishox2_compress functions) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of 'in' in bytes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>output buffer - should be large enough to hold de-compressed output </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">olen</td><td>length of 'out' buffer in bytes. Can be omitted if sufficient buffer is provided </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usx_hcodes</td><td>Horizontal codes (array of bytes). See macro section for samples. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usx_hcode_lens</td><td>Length of each element in usx_hcodes array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usx_freq_seq</td><td>Frequently occuring sequences. See USX_FREQ_SEQ_* macros for samples </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usx_templates</td><td>Templates of frequently occuring patterns. See USX_TEMPLATES macro. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec21ab3385bd5920e2ce6c63d1ebf418" name="aec21ab3385bd5920e2ce6c63d1ebf418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec21ab3385bd5920e2ce6c63d1ebf418">&#9670;&nbsp;</a></span>unishox2_decompress_lines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int unishox2_decompress_lines </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unishox2_8h.html#a147b75fc8de9ab4176b7cfb3d341f361">UNISHOX_API_OUT_AND_LEN</a>(char *out, int olen)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>usx_hcodes</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>usx_hcode_lens</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>usx_freq_seq</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>usx_templates</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structus__lnk__lst.html">us_lnk_lst</a> *&#160;</td>
          <td class="paramname"><em>prev_lines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >More Comprehensive API for de-compressing array of strings <br  />
This function is not be used in conjuction with <a class="el" href="unishox2_8h.html#a5fc0490b257381a887c27e6c986e76bc">unishox2_compress_lines()</a></p>
<p >See <a class="el" href="unishox2_8h.html#a1fd9aa9f14850e527e6b46089cf83d1a">unishox2_decompress()</a> function for parameter definitions. <br  />
Typically an array is compressed using <a class="el" href="unishox2_8h.html#a5fc0490b257381a887c27e6c986e76bc">unishox2_compress_lines()</a> and <br  />
a header (.h) file is generated using the resultant compressed array. <br  />
This header file can be used in another program with another decompress <br  />
routine which takes this compressed array as parameter and index to be <br  />
decompressed. </p>

</div>
</div>
<a id="a3e5c00a0c5db7979d94b0b294908a04e" name="a3e5c00a0c5db7979d94b0b294908a04e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e5c00a0c5db7979d94b0b294908a04e">&#9670;&nbsp;</a></span>unishox2_decompress_simple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int unishox2_decompress_simple </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Simple API for decompressing a string </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>Input compressed bytes (output of unishox2_compress functions) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of 'in' in bytes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>output buffer for ASCII / UTF-8 string - should be large enough </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ab9dde3029bc4d65f66f0fd275e9e85ac" name="ab9dde3029bc4d65f66f0fd275e9e85ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9dde3029bc4d65f66f0fd275e9e85ac">&#9670;&nbsp;</a></span>len_masks</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> len_masks[] = {0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE, 0xFF}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Mask for retrieving each code to be decoded according to its length <br  />
Same as usx_mask so redundant </p>

</div>
</div>
<a id="ad8e8ea73201a929db219744e046a7012" name="ad8e8ea73201a929db219744e046a7012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e8ea73201a929db219744e046a7012">&#9670;&nbsp;</a></span>usx_code_94</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> usx_code_94[94]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Stores position of letter in usx_sets. First 3 bits - position in usx_hcodes Next 5 bits - position in usx_vcodes </p>

</div>
</div>
<a id="a26a0225aca0ec7d93e62587226d752f3" name="a26a0225aca0ec7d93e62587226d752f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26a0225aca0ec7d93e62587226d752f3">&#9670;&nbsp;</a></span>usx_sets</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> usx_sets[][28]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {{  0, <span class="charliteral">&#39; &#39;</span>, <span class="charliteral">&#39;e&#39;</span>, <span class="charliteral">&#39;t&#39;</span>, <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;o&#39;</span>, <span class="charliteral">&#39;i&#39;</span>, <span class="charliteral">&#39;n&#39;</span>,</div>
<div class="line">                        <span class="charliteral">&#39;s&#39;</span>, <span class="charliteral">&#39;r&#39;</span>, <span class="charliteral">&#39;l&#39;</span>, <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;h&#39;</span>, <span class="charliteral">&#39;u&#39;</span>, <span class="charliteral">&#39;p&#39;</span>, <span class="charliteral">&#39;m&#39;</span>, <span class="charliteral">&#39;b&#39;</span>,</div>
<div class="line">                        <span class="charliteral">&#39;g&#39;</span>, <span class="charliteral">&#39;w&#39;</span>, <span class="charliteral">&#39;f&#39;</span>, <span class="charliteral">&#39;y&#39;</span>, <span class="charliteral">&#39;v&#39;</span>, <span class="charliteral">&#39;k&#39;</span>, <span class="charliteral">&#39;q&#39;</span>, <span class="charliteral">&#39;j&#39;</span>, <span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;z&#39;</span>},</div>
<div class="line">                       {<span class="charliteral">&#39;&quot;&#39;</span>, <span class="charliteral">&#39;{&#39;</span>, <span class="charliteral">&#39;}&#39;</span>, <span class="charliteral">&#39;_&#39;</span>, <span class="charliteral">&#39;&lt;&#39;</span>, <span class="charliteral">&#39;&gt;&#39;</span>, <span class="charliteral">&#39;:&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>,</div>
<div class="line">                          0, <span class="charliteral">&#39;[&#39;</span>, <span class="charliteral">&#39;]&#39;</span>, <span class="charliteral">&#39;\\&#39;</span>, <span class="charliteral">&#39;;&#39;</span>, <span class="charliteral">&#39;\&#39;&#39;</span>, <span class="charliteral">&#39;\t&#39;</span>, <span class="charliteral">&#39;@&#39;</span>, <span class="charliteral">&#39;*&#39;</span>, <span class="charliteral">&#39;&amp;&#39;</span>,</div>
<div class="line">                        <span class="charliteral">&#39;?&#39;</span>, <span class="charliteral">&#39;!&#39;</span>, <span class="charliteral">&#39;^&#39;</span>, <span class="charliteral">&#39;|&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;~&#39;</span>, <span class="charliteral">&#39;`&#39;</span>, 0, 0, 0},</div>
<div class="line">                       {  0, <span class="charliteral">&#39;,&#39;</span>, <span class="charliteral">&#39;.&#39;</span>, <span class="charliteral">&#39;0&#39;</span>, <span class="charliteral">&#39;1&#39;</span>, <span class="charliteral">&#39;9&#39;</span>, <span class="charliteral">&#39;2&#39;</span>, <span class="charliteral">&#39;5&#39;</span>, <span class="charliteral">&#39;-&#39;</span>,</div>
<div class="line">                        <span class="charliteral">&#39;/&#39;</span>, <span class="charliteral">&#39;3&#39;</span>, <span class="charliteral">&#39;4&#39;</span>, <span class="charliteral">&#39;6&#39;</span>, <span class="charliteral">&#39;7&#39;</span>, <span class="charliteral">&#39;8&#39;</span>, <span class="charliteral">&#39;(&#39;</span>, <span class="charliteral">&#39;)&#39;</span>, <span class="charliteral">&#39; &#39;</span>,</div>
<div class="line">                        <span class="charliteral">&#39;=&#39;</span>, <span class="charliteral">&#39;+&#39;</span>, <span class="charliteral">&#39;$&#39;</span>, <span class="charliteral">&#39;%&#39;</span>, <span class="charliteral">&#39;#&#39;</span>, 0, 0, 0, 0, 0}}</div>
</div><!-- fragment -->
<p>This 2D array has the characters for the sets USX_ALPHA, USX_SYM and USX_NUM. Where a character cannot fit into a byte, 0 is used and handled in code. </p>

</div>
</div>
<a id="a3b3914e2fcfcedd6fe942f752ded63f6" name="a3b3914e2fcfcedd6fe942f752ded63f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b3914e2fcfcedd6fe942f752ded63f6">&#9670;&nbsp;</a></span>usx_vcode_lens</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> usx_vcode_lens[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {  2,    3,    3,    4,    4,    4,    4,</div>
<div class="line">                           4,    5,    5,    6,    6,    6,    7,</div>
<div class="line">                           7,    7,    7,    7,    8,    8,    8,</div>
<div class="line">                           8,    8,    8,    8,    8,    8,    8 }</div>
</div><!-- fragment -->
<p>Length of each veritical code. </p>

</div>
</div>
<a id="aa8ab0186ce66a2b8227bf72b2a9499a6" name="aa8ab0186ce66a2b8227bf72b2a9499a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ab0186ce66a2b8227bf72b2a9499a6">&#9670;&nbsp;</a></span>usx_vcode_lookup</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> usx_vcode_lookup[36]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">  (1 &lt;&lt; 5) + 0,  (1 &lt;&lt; 5) + 0,  (2 &lt;&lt; 5) + 1,  (2 &lt;&lt; 5) + 2,  </div>
<div class="line">  (3 &lt;&lt; 5) + 3,  (3 &lt;&lt; 5) + 4,  (3 &lt;&lt; 5) + 5,  (3 &lt;&lt; 5) + 6,  </div>
<div class="line">  (3 &lt;&lt; 5) + 7,  (3 &lt;&lt; 5) + 7,  (4 &lt;&lt; 5) + 8,  (4 &lt;&lt; 5) + 9,  </div>
<div class="line">  (5 &lt;&lt; 5) + 10, (5 &lt;&lt; 5) + 10, (5 &lt;&lt; 5) + 11, (5 &lt;&lt; 5) + 11, </div>
<div class="line">  (5 &lt;&lt; 5) + 12, (5 &lt;&lt; 5) + 12, (6 &lt;&lt; 5) + 13, (6 &lt;&lt; 5) + 14,</div>
<div class="line">  (6 &lt;&lt; 5) + 15, (6 &lt;&lt; 5) + 15, (6 &lt;&lt; 5) + 16, (6 &lt;&lt; 5) + 16, </div>
<div class="line">  (6 &lt;&lt; 5) + 17, (6 &lt;&lt; 5) + 17, (7 &lt;&lt; 5) + 18, (7 &lt;&lt; 5) + 19,</div>
<div class="line">  (7 &lt;&lt; 5) + 20, (7 &lt;&lt; 5) + 21, (7 &lt;&lt; 5) + 22, (7 &lt;&lt; 5) + 23,</div>
<div class="line">  (7 &lt;&lt; 5) + 24, (7 &lt;&lt; 5) + 25, (7 &lt;&lt; 5) + 26, (7 &lt;&lt; 5) + 27</div>
<div class="line">}</div>
</div><!-- fragment --><p >Vertical decoder lookup table - 3 bits code len, 5 bytes vertical pos code len is one less as 8 cannot be accommodated in 3 bits </p>

</div>
</div>
<a id="a7bc351d1b7a92d0654c3035dfe548a1d" name="a7bc351d1b7a92d0654c3035dfe548a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bc351d1b7a92d0654c3035dfe548a1d">&#9670;&nbsp;</a></span>usx_vcodes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="unishox2_8c.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> usx_vcodes[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= { 0x00, 0x40, 0x60, 0x80, 0x90, 0xA0, 0xB0,</div>
<div class="line">                        0xC0, 0xD0, 0xD8, 0xE0, 0xE4, 0xE8, 0xEC,</div>
<div class="line">                        0xEE, 0xF0, 0xF2, 0xF4, 0xF6, 0xF7, 0xF8,</div>
<div class="line">                        0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF }</div>
</div><!-- fragment -->
<p>Vertical codes starting from the MSB. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="unishox2_8c.html">unishox2.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
</body>
</html>
